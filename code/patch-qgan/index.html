<!DOCTYPE html>
<html lang="en-us">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Quantum Patch GAN - Quantum Machine Learning Tutorial</title>
<meta name="description" content="An introduction to implement a quantum GAN.">
<meta name="generator" content="Hugo 0.140.2">
<link href="https://qml-tutorial.github.io//index.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://qml-tutorial.github.io/code/patch-qgan/">
<link rel="stylesheet" href="https://qml-tutorial.github.io/css/theme.min.css">
<link rel="stylesheet" href="https://qml-tutorial.github.io/css/chroma.min.css">
<script defer src="https://qml-tutorial.github.io//js/fontawesome6/all.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js" integrity="sha256-H3cjtrm/ztDeuhCN9I4yh4iN2Ybx/y1RM7rMmAesA0k=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha256-4XodgW4TwIJuDtf+v6vDJ39FVxI0veC/kSCCmnFp7ck=" crossorigin="anonymous"></script>
<script src="https://qml-tutorial.github.io/js/bundle.js"></script><style>
:root {}
</style>
<meta property="og:url" content="https://qml-tutorial.github.io/code/patch-qgan/">
  <meta property="og:site_name" content="Quantum Machine Learning Tutorial">
  <meta property="og:title" content="Quantum Patch GAN">
  <meta property="og:description" content="An introduction to implement a quantum GAN.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="code">
    <meta property="og:image" content="https://qml-tutorial.github.io/images/og-image.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://qml-tutorial.github.io/images/og-image.png">
  <meta name="twitter:title" content="Quantum Patch GAN">
  <meta name="twitter:description" content="An introduction to implement a quantum GAN.">

  <meta itemprop="name" content="Quantum Patch GAN">
  <meta itemprop="description" content="An introduction to implement a quantum GAN.">
  <meta itemprop="wordCount" content="974">
  <meta itemprop="image" content="https://qml-tutorial.github.io/images/og-image.png">
  <meta itemprop="keywords" content="Quantum Neural Network"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
        onload="renderMathInElement(document.body,{ delimiters: [ { left: '$$', right: '$$', display: true }, { left: '\\[', right: '\\]', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false } ] });"></script>
</head>
<body><div class="container"><header>
<h1>Quantum Machine Learning Tutorial</h1>
<p class="description">A Hands-on Tutorial for Machine Learning Practitioners and Researchers</p>

</header>
<div class="global-menu">
<nav>
<ul>
<li id="home" class=""><a href="/"><i class='fa fa-heart'></i>&nbsp;Home</a></li>
<li class=""><a href="/resources/">Resources</a></li></ul>
</nav>
</div>

<div class="content-container">
<main><h1>Quantum Patch GAN</h1>
<p>In this tutorial, we demonstrate how to implement a quantum patch GAN introduced in Chapter xxx for the generation of hand-written digit of five. The whole pipeline includes following steps:</p>
<ol>
<li>Load and pre-process the dataset</li>
<li>Build the classical discriminator</li>
<li>Build the quantum generator</li>
<li>Train the quantum patch GAN</li>
<li>Visualize the generated images</li>
</ol>
<p>We begin by importing required libraries:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> torch
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> torch.nn <span style="color:#66d9ef">as</span> nn
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> torch.optim <span style="color:#66d9ef">as</span> optim
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> torch.utils.data <span style="color:#f92672">import</span> Dataset, DataLoader
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pennylane <span style="color:#66d9ef">as</span> qml
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> math
</span></span></code></pre></div><h2 id="step-1-dataset-preparation">Step 1: Dataset Preparation</h2>
<p>We will use the <a href="https://archive.ics.uci.edu/dataset/80/optical+recognition+of+handwritten+digits">Optical Recognition of Handwritten Digits dataset</a>, where each data point represents an $8\times 8$ grayscale image. Letâ€™s start by defining a custom dataset class to load and process the data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OptdigitsData</span>(Dataset):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data_path, label):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Dataset class for Optical Recognition of Handwritten Digits.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span>__init__()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">with</span> open(data_path, <span style="color:#e6db74">&#39;r&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> line <span style="color:#f92672">in</span> f<span style="color:#f92672">.</span>readlines():
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> int(line<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;,&#39;</span>)[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">==</span> label:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># Normalize image pixel values from [0,16) to [0, 1)</span>
</span></span><span style="display:flex;"><span>                    image <span style="color:#f92672">=</span> [int(pixel)<span style="color:#f92672">/</span><span style="color:#ae81ff">16</span> <span style="color:#66d9ef">for</span> pixel <span style="color:#f92672">in</span> line<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;,&#39;</span>)[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]
</span></span><span style="display:flex;"><span>                    image <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(image, dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>float32)<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>data<span style="color:#f92672">.</span>append(image)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>label <span style="color:#f92672">=</span> label
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __len__(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> len(self<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __getitem__(self, index):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> torch<span style="color:#f92672">.</span>from_numpy(self<span style="color:#f92672">.</span>data[index]), self<span style="color:#f92672">.</span>label
</span></span></code></pre></div><p>After defining the dataset class, we visualize a few examples to better understand the structure of the dataset.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">visualize_dataset</span>(data_path):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Visualizes the dataset by displaying examples for each digit label.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">5</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>):
</span></span><span style="display:flex;"><span>        plt<span style="color:#f92672">.</span>subplot(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> OptdigitsData(data_path, label<span style="color:#f92672">=</span>i)
</span></span><span style="display:flex;"><span>        plt<span style="color:#f92672">.</span>imshow(data[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>], cmap<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;gray&#39;</span>)
</span></span><span style="display:flex;"><span>        plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Label: </span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        plt<span style="color:#f92672">.</span>axis(<span style="color:#e6db74">&#39;off&#39;</span>)
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>tight_layout()
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>show()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>visualize_dataset(<span style="color:#e6db74">&#39;code/chapter5_qnn/optical+recognition+of+handwritten+digits/optdigits.tra&#39;</span>)
</span></span></code></pre></div><h2 id="step-2-building-the-classical-discriminator">Step 2: Building the Classical Discriminator</h2>
<p>The discriminator is a classical neural network responsible for distinguishing real images from fake ones. It consists of fully connected layers with ReLU activations. The output is re-scaled into (0,1) via the Sigmoid function to be a reasonable indicator whether the input image is real or fake.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ClassicalDiscriminator</span>(nn<span style="color:#f92672">.</span>Module):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    A classical discriminator for classifying real and fake images.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, input_shape):
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span>__init__()
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>model <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>Sequential(
</span></span><span style="display:flex;"><span>            nn<span style="color:#f92672">.</span>Flatten(),
</span></span><span style="display:flex;"><span>            nn<span style="color:#f92672">.</span>Linear(int(np<span style="color:#f92672">.</span>prod(input_shape)), <span style="color:#ae81ff">256</span>),
</span></span><span style="display:flex;"><span>            nn<span style="color:#f92672">.</span>ReLU(),
</span></span><span style="display:flex;"><span>            nn<span style="color:#f92672">.</span>Dropout(),
</span></span><span style="display:flex;"><span>            nn<span style="color:#f92672">.</span>Linear(<span style="color:#ae81ff">256</span>, <span style="color:#ae81ff">128</span>),
</span></span><span style="display:flex;"><span>            nn<span style="color:#f92672">.</span>ReLU(),
</span></span><span style="display:flex;"><span>            nn<span style="color:#f92672">.</span>Dropout(),
</span></span><span style="display:flex;"><span>            nn<span style="color:#f92672">.</span>Linear(<span style="color:#ae81ff">128</span>, <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>            nn<span style="color:#f92672">.</span>Sigmoid()
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, img):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>model(img)
</span></span></code></pre></div><h2 id="step-3-defining-the-quantum-generator">Step 3: Defining the Quantum Generator</h2>
<p>The quantum generator is responsible for generating patches of images using parameterized quantum circuits (PQC). Each patch is constructed using a quantum circuit with trainable parameters.</p>
<h3 id="parameterized-quantum-circuit-pqc">Parameterized Quantum Circuit (PQC)</h3>
<p>The PQC applies layers of single-qubit rotation gates and entangling gates to the input qubits.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">PQC</span>(params):
</span></span><span style="display:flex;"><span>    n_layer, n_qubit <span style="color:#f92672">=</span> params<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>], params<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_layer):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n_qubit):
</span></span><span style="display:flex;"><span>            qml<span style="color:#f92672">.</span>Rot(params[i, j, <span style="color:#ae81ff">0</span>], params[i, j, <span style="color:#ae81ff">1</span>], params[i, j, <span style="color:#ae81ff">2</span>], wires<span style="color:#f92672">=</span>j)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Control Z gates</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n_qubit <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>            qml<span style="color:#f92672">.</span>CZ(wires<span style="color:#f92672">=</span>[j, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])
</span></span></code></pre></div><h3 id="quantum-generator-circuit">Quantum Generator Circuit</h3>
<p>This quantum generator circuit (sub-generator) converts the latent variable $\bm{z}$ into the latent quantum state $\ket{\bm{z}}$, applies the PQC, conducts partial measurements on the aucillary system $\mathcal{A}$, and returns the probabilities of each computational basis of the remaining system as the generated pixel values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">QuantumGenerator</span>(params, z<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, n_qubit_a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    n_qubit <span style="color:#f92672">=</span> params<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># angle encoding of latent state z</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_qubit):
</span></span><span style="display:flex;"><span>        qml<span style="color:#f92672">.</span>RY(z[i], wires<span style="color:#f92672">=</span>i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PQC(params)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># partial measurement on the ancillary qubits</span>
</span></span><span style="display:flex;"><span>    qml<span style="color:#f92672">.</span>measure(wires<span style="color:#f92672">=</span>n_qubit<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> qml<span style="color:#f92672">.</span>probs(wires<span style="color:#f92672">=</span>range(n_qubit<span style="color:#f92672">-</span>n_qubit_a))
</span></span></code></pre></div><h3 id="quantum-patch-generator">Quantum Patch Generator</h3>
<p>With the sub-generators, the quantum patch generator combines outputed patches from multiple sub-generators to generate the whole image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PatchQuantumGenerator</span>(nn<span style="color:#f92672">.</span>Module):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Combines patches generated by quantum circuits into full images.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, qnode_generator, n_generator, n_qubit, n_qubit_a, n_layer):
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span>__init__()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>params_generator <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>ParameterList([
</span></span><span style="display:flex;"><span>            nn<span style="color:#f92672">.</span>Parameter(torch<span style="color:#f92672">.</span>rand((n_layer, n_qubit, <span style="color:#ae81ff">3</span>)), requires_grad<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n_generator)
</span></span><span style="display:flex;"><span>        ])
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>qnode_generator <span style="color:#f92672">=</span> qnode_generator
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>n_qubit_a <span style="color:#f92672">=</span> n_qubit_a
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, zs):
</span></span><span style="display:flex;"><span>        images <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> z <span style="color:#f92672">in</span> zs:
</span></span><span style="display:flex;"><span>            patches <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> params <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>params_generator:
</span></span><span style="display:flex;"><span>                patch <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>qnode_generator(params, z<span style="color:#f92672">=</span>z, n_qubit_a<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>n_qubit_a)<span style="color:#f92672">.</span>float()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># post-processing: min-max scaling</span>
</span></span><span style="display:flex;"><span>                patch <span style="color:#f92672">=</span> (patch <span style="color:#f92672">-</span> patch<span style="color:#f92672">.</span>min()) <span style="color:#f92672">/</span> (patch<span style="color:#f92672">.</span>max() <span style="color:#f92672">-</span> patch<span style="color:#f92672">.</span>min() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1e-8</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                patches<span style="color:#f92672">.</span>append(patch<span style="color:#f92672">.</span>unsqueeze(<span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>            patches <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>cat(patches, dim<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            images<span style="color:#f92672">.</span>append(patches<span style="color:#f92672">.</span>flatten()<span style="color:#f92672">.</span>unsqueeze(<span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> torch<span style="color:#f92672">.</span>cat(images, dim<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><h2 id="step-4-training-the-patch-quantum-gan">Step 4: Training the Patch Quantum GAN</h2>
<h3 id="initializing-the-quantum-gan">Initializing the Quantum GAN</h3>
<p>We initialize the quantum generator and classical discriminator along with their optimizers.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Hyperparameters</span>
</span></span><span style="display:flex;"><span>torch<span style="color:#f92672">.</span>manual_seed(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>image_width <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>image_height <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>n_generator <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>n_qubit_d <span style="color:#f92672">=</span> int(np<span style="color:#f92672">.</span>log2((image_width <span style="color:#f92672">*</span> image_height) <span style="color:#f92672">//</span> n_generator))
</span></span><span style="display:flex;"><span>n_qubit_a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>n_qubit <span style="color:#f92672">=</span> n_qubit_d <span style="color:#f92672">+</span> n_qubit_a
</span></span><span style="display:flex;"><span>n_layer <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Quantum device</span>
</span></span><span style="display:flex;"><span>dev <span style="color:#f92672">=</span> qml<span style="color:#f92672">.</span>device(<span style="color:#e6db74">&#34;lightning.qubit&#34;</span>, wires<span style="color:#f92672">=</span>n_qubit)
</span></span><span style="display:flex;"><span>qnode_generator <span style="color:#f92672">=</span> qml<span style="color:#f92672">.</span>QNode(QuantumGenerator, dev)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initialize generator and discriminator</span>
</span></span><span style="display:flex;"><span>discriminator <span style="color:#f92672">=</span> ClassicalDiscriminator([image_height, image_width])
</span></span><span style="display:flex;"><span>discriminator<span style="color:#f92672">.</span>train()
</span></span><span style="display:flex;"><span>generator <span style="color:#f92672">=</span> PatchQuantumGenerator(qnode_generator, n_generator, n_qubit, n_qubit_a, n_layer)
</span></span><span style="display:flex;"><span>generator<span style="color:#f92672">.</span>train()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Optimizers</span>
</span></span><span style="display:flex;"><span>lr_generator <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.3</span>
</span></span><span style="display:flex;"><span>lr_discriminator <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e-2</span>
</span></span><span style="display:flex;"><span>opt_discriminator <span style="color:#f92672">=</span> optim<span style="color:#f92672">.</span>SGD(discriminator<span style="color:#f92672">.</span>parameters(), lr<span style="color:#f92672">=</span>lr_discriminator)
</span></span><span style="display:flex;"><span>opt_generator <span style="color:#f92672">=</span> optim<span style="color:#f92672">.</span>SGD(generator<span style="color:#f92672">.</span>parameters(), lr<span style="color:#f92672">=</span>lr_generator)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Construct dataset and dataloader</span>
</span></span><span style="display:flex;"><span>batch_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>dataset <span style="color:#f92672">=</span> OptdigitsData(<span style="color:#e6db74">&#39;code/chapter5_qnn/optical+recognition+of+handwritten+digits/optdigits.tra&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>dataloader <span style="color:#f92672">=</span> DataLoader(dataset, batch_size<span style="color:#f92672">=</span>batch_size, shuffle<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, drop_last<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Loss function</span>
</span></span><span style="display:flex;"><span>loss_fn <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>BCELoss()
</span></span><span style="display:flex;"><span>labels_real <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>ones(batch_size, dtype<span style="color:#f92672">=</span>torch<span style="color:#f92672">.</span>float)
</span></span><span style="display:flex;"><span>labels_fake <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>zeros(batch_size, dtype<span style="color:#f92672">=</span>torch<span style="color:#f92672">.</span>float)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Testing setup</span>
</span></span><span style="display:flex;"><span>n_test <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>z_test <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>rand(n_test, n_qubit) <span style="color:#f92672">*</span> math<span style="color:#f92672">.</span>pi
</span></span></code></pre></div><h3 id="training-loop">Training Loop</h3>
<p>The GAN is trained using alternating updates for the discriminator and the generator. The generator learns to produce images that fool the discriminator. We save the generated images every epoch to record the behaviour of the generator during training.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>n_epoch <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>record <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_epoch):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> data, _ <span style="color:#f92672">in</span> dataloader:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        zs <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>rand(batch_size, n_qubit) <span style="color:#f92672">*</span> math<span style="color:#f92672">.</span>pi
</span></span><span style="display:flex;"><span>        image_fake <span style="color:#f92672">=</span> generator(zs)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Training the discriminator</span>
</span></span><span style="display:flex;"><span>        discriminator<span style="color:#f92672">.</span>zero_grad()
</span></span><span style="display:flex;"><span>        pred_fake <span style="color:#f92672">=</span> discriminator(image_fake<span style="color:#f92672">.</span>detach())
</span></span><span style="display:flex;"><span>        pred_real <span style="color:#f92672">=</span> discriminator(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        loss_discriminator <span style="color:#f92672">=</span> loss_fn(pred_fake<span style="color:#f92672">.</span>squeeze(), labels_fake) <span style="color:#f92672">+</span> loss_fn(pred_real<span style="color:#f92672">.</span>squeeze(), labels_real)
</span></span><span style="display:flex;"><span>        loss_discriminator<span style="color:#f92672">.</span>backward()
</span></span><span style="display:flex;"><span>        opt_discriminator<span style="color:#f92672">.</span>step()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Training the generator</span>
</span></span><span style="display:flex;"><span>        generator<span style="color:#f92672">.</span>zero_grad()
</span></span><span style="display:flex;"><span>        pred_fake <span style="color:#f92672">=</span> discriminator(image_fake)
</span></span><span style="display:flex;"><span>        loss_generator <span style="color:#f92672">=</span> loss_fn(pred_fake<span style="color:#f92672">.</span>squeeze(), labels_real)
</span></span><span style="display:flex;"><span>        loss_generator<span style="color:#f92672">.</span>backward()
</span></span><span style="display:flex;"><span>        opt_generator<span style="color:#f92672">.</span>step()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;The </span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">-th epoch: discriminator loss=</span><span style="color:#e6db74">{</span>loss_discriminator<span style="color:#e6db74">:</span><span style="color:#e6db74"> 0.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, generator loss=</span><span style="color:#e6db74">{</span>loss_generator<span style="color:#e6db74">:</span><span style="color:#e6db74"> 0.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># test</span>
</span></span><span style="display:flex;"><span>    generator<span style="color:#f92672">.</span>eval()
</span></span><span style="display:flex;"><span>    image_generated <span style="color:#f92672">=</span> generator(z_test)<span style="color:#f92672">.</span>view(n_test, image_height, image_width)<span style="color:#f92672">.</span>detach()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    record[str(i)] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;loss_discriminator&#39;</span>: loss_discriminator<span style="color:#f92672">.</span>item(),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;loss_generator&#39;</span>: loss_generator<span style="color:#f92672">.</span>item(),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;image_generated&#39;</span>: image_generated<span style="color:#f92672">.</span>numpy()<span style="color:#f92672">.</span>tolist()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    generator<span style="color:#f92672">.</span>train()
</span></span></code></pre></div><h2 id="step-5-visualizing-the-generated-images">Step 5: Visualizing the Generated Images</h2>
<p>After training, we can visualize the images generated by the quantum generator.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>n_epochs_to_visualize <span style="color:#f92672">=</span> len(record) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>n_images_per_epoch <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fig, axes <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(n_epochs_to_visualize, n_images_per_epoch, figsize<span style="color:#f92672">=</span>(n_images_per_epoch, n_epochs_to_visualize))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterate through the recorded epochs and visualize generated images</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> epoch_idx, (epoch, data) <span style="color:#f92672">in</span> enumerate(record<span style="color:#f92672">.</span>items()):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> epoch_idx <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>    images <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(data[<span style="color:#e6db74">&#39;image_generated&#39;</span>])
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> img_idx <span style="color:#f92672">in</span> range(n_images_per_epoch):
</span></span><span style="display:flex;"><span>        ax <span style="color:#f92672">=</span> axes[epoch_idx <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>, img_idx]
</span></span><span style="display:flex;"><span>        ax<span style="color:#f92672">.</span>imshow(images[img_idx], cmap<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;gray&#39;</span>)
</span></span><span style="display:flex;"><span>        ax<span style="color:#f92672">.</span>axis(<span style="color:#e6db74">&#39;off&#39;</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Add epoch information to the title of each row</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> img_idx <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            ax<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Epoch </span><span style="color:#e6db74">{</span>epoch<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>tight_layout()
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><div class="edit-meta">

<br></div><nav class="pagination"><a class="nav nav-prev" href="https://qml-tutorial.github.io/code/classifier/" title="Quantum Classifier"><i class="fas fa-arrow-left" aria-hidden="true"></i>&nbsp;Prev - Quantum Classifier</a>
<a class="nav nav-next" href="https://qml-tutorial.github.io/code/transformer/" title="Tranformer">Next - Tranformer <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main>
<div class="sidebar">

<nav class="open-menu">
<ul>
<li class=""><a href="https://qml-tutorial.github.io/">Home</a></li>

<li class=""><a href="https://qml-tutorial.github.io/getting-started/">Getting Started</a>
  
</li>

<li class=""><a href="https://qml-tutorial.github.io/chapter1/">Chapter 1 Introduction of QML</a>
  
</li>

<li class=""><a href="https://qml-tutorial.github.io/chapter2/">Chapter 2 Basis of Quantum Computing</a>
  
<ul class="sub-menu">
<li class=""><a href="https://qml-tutorial.github.io/chapter2/1/">Chapter 2.1 From Classical Bits to Quantum Bits</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter2/2/">Chapter 2.2 From Digital Logical Circuit to Quantum Circuit Model</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter2/3/">Chapter 2.3 Quantum Read-in and Read-out protocols</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter2/4/">Chapter 2.4 Quantum Linear Algebra</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter2/5/">Chapter 2.5 Recent Advancements</a></li>
</ul>
  
</li>

<li class=""><a href="https://qml-tutorial.github.io/chapter3/">Chapter 3 Quantum Kernel Methods</a>
  
<ul class="sub-menu">
<li class=""><a href="https://qml-tutorial.github.io/chapter3/1/">Chapter 3.1 Classical Kernel</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter3/2/">Chapter 3.2 Quantum Kernel Machines</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter3/3/">Chapter 3.3 Theoretical Foundations</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter3/4/">Chapter 3.4 Recent Advancements</a></li>
</ul>
  
</li>

<li class=""><a href="https://qml-tutorial.github.io/chapter4/">Chapter 4 Quantum Neural Networks</a>
  
<ul class="sub-menu">
<li class=""><a href="https://qml-tutorial.github.io/chapter4/1/">Chapter 4.1 Classical Neural Networks</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter4/2/">Chapter 4.2 Fault-tolerant Quantum Perceptron</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter4/3/">Chapter 4.3 Near-term quantum neural networks</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter4/4/">Chapter 4.4 Theoretical Foundations of QNNs</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter4/5/">Chapter 4.5 Recent Advancements</a></li>
</ul>
  
</li>

<li class=""><a href="https://qml-tutorial.github.io/chapter5/">Chapter 5 Quantum Transformer</a>
  
<ul class="sub-menu">
<li class=""><a href="https://qml-tutorial.github.io/chapter5/1/">Chapter 5.1 Classical Transformer</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter5/2/">Chapter 5.2 Fault-tolerant Quantum Transformer</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter5/3/">Chapter 5.3 Runtime Analysis with Quadratic Speedups</a></li>
<li class=""><a href="https://qml-tutorial.github.io/chapter5/4/">Chapter 5.4 Recent Advancements</a></li>
</ul>
  
</li>

<li class="parent"><a href="https://qml-tutorial.github.io/code/">Code Examples</a>
  
<ul class="sub-menu">
<li class=""><a href="https://qml-tutorial.github.io/code/data-encode/">Data Encoding</a></li>
<li class=""><a href="https://qml-tutorial.github.io/code/kernel-mnist/">Classification on MNIST</a></li>
<li class=""><a href="https://qml-tutorial.github.io/code/classifier/">Quantum Classifier</a></li>
<li class="active"><a href="https://qml-tutorial.github.io/code/patch-qgan/">Quantum Patch GAN</a></li>
<li class=""><a href="https://qml-tutorial.github.io/code/transformer/">Tranformer</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>

</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
